# üî¶ App Resolver Workflow
#
# This workflow intelligently determines which Fusion applications have been affected
# by changes in a pull request or push. It uses git history analysis to identify
# modified applications and triggers builds only for those that need it, optimizing
# CI/CD performance and resource usage.
#
# Key Features:
# - Smart Detection: Only builds applications that have actual changes
# - Monorepo Support: Works with multiple apps in the same repository  
# - Change Analysis: Uses git diff to analyze file changes across commits
# - Matrix Strategy: Builds multiple affected apps in parallel
# - Visual Feedback: Provides clear summary of detected changes
# - Efficient CI: Prevents unnecessary builds for unchanged applications
#
# Workflow Process:
# 1. app-resolver job:
#    - Checks out repository with full git history
#    - Uses fusion-action-app-change to detect modified applications
#    - Outputs list of changed apps with names and paths
#    - Creates visual summary table for easy review
# 2. build job:
#    - Only runs if changes are detected
#    - Uses matrix strategy to build all affected apps in parallel
#    - Calls the reusable build.yml workflow for each app
#    - Deploys to PR environment for testing
#
# Detection Logic:
# - Analyzes git diff between base and head commits
# - Identifies changes within app directories (apps/**)
# - Considers both direct changes and dependency modifications
# - Outputs structured JSON with app metadata
#
# Output Format:
# The workflow outputs a JSON array of changed applications:
# ```json
# [
#   {
#     "name": "basic",
#     "path": "./apps/basic"
#   },
#   {
#     "name": "bare", 
#     "path": "./apps/bare"
#   }
# ]
# ```
#
# Integration:
# - Designed to be called by PR workflow
# - Can be triggered manually for testing
# - Provides foundation for selective deployment strategies
# - Supports both pull request and push events
#
# Benefits:
# - Faster CI: Only builds what changed
# - Resource Efficient: Reduces compute usage
# - Clear Visibility: Shows exactly what will be built
# - Scalable: Works with any number of applications

name:  üî¶ App Resolver  

on:
  workflow_call:
    inputs:
      triggered-by:
        required: false
        type: string
        default: 'manual'

jobs:
  app-resolver:
    name: üõ†Ô∏è App Resolver
    runs-on: ubuntu-latest
    outputs:
      changed-apps: ${{ steps.detect.outputs.changed-apps }}
    steps:
        # Checkout the repository to analyze changes with depth of 0 to get all history
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Detect changes
        id: detect
        uses: equinor/fusion-action-app-change@v0

        # Print changed applications to $GITHUB_STEP_SUMMARY as one comment with all apps in table format
      - name: üõ†Ô∏è Changed Applications
        if: steps.detect.outputs.has-changes == 'true'
        run: |
          echo "## üõ†Ô∏è Changed Applications" >> $GITHUB_STEP_SUMMARY

          echo "The following applications have changes in this pull request and will be built and deployed to the pr environment." >> $GITHUB_STEP_SUMMARY

          echo "| Application Name | Path |" >> $GITHUB_STEP_SUMMARY
          echo "|------------------|------|" >> $GITHUB_STEP_SUMMARY
          printf '%s' '${{ steps.detect.outputs.changed-apps }}' | jq -r 'if type=="string" then fromjson else . end | .[] | "| " + .name + " | " + .path + " |"' >> $GITHUB_STEP_SUMMARY

  build:
    name: üõ†Ô∏è Build Workflow
    needs: app-resolver
    if: needs.app-resolver.outputs.changed-apps != ''
    permissions:
      contents: read
      id-token: write
      issues: write
      pull-requests: write
    strategy:
      matrix:
        app: ${{ fromJson(needs.app-resolver.outputs.changed-apps) }}
    uses: ./.github/workflows/build.yml
    with:
      app-name: ${{ matrix.app.name }}
      work-dir: ${{ matrix.app.path }}
      environment: '["pr"]'
    
